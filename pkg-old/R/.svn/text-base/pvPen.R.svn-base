#' @encoding UTF-8
#' @title Penalized regression detection strategy
#' @name pvPen
#' @description pvPen implements a detection strategy based on the use of the Lasso regression along with BIC
#'  type detection criteria. The methodology follows two main steps: 
#'  \itemize{
#'  \item Lasso regression (with a positive constraint on the regression coefficients) for a grid of constraint 
#'  parameters
#'  \item selection on the drug associated with the ae of interest according to the BIC. 
#'  }
#'  This function heavily relies on the highly efficient \code{glmnet} package. \code{pvPen} 
#' @param object an object of class PvInd
#' @param cov a character vector indicating which covariate have to be used in the analyses. 
#' Such variables are first use in a logistic regression model and the residual is then used as the outcome 
#' in the penalized regression
#' @export
#' 
#' 
#
# posConst arg to be added

pvPen <- function(object, cov=NULL, aeLab="all", detectCriter=c("BIC", "AIC"), nlambda=500, nBoot=100, parallel=F, nCore=NULL){
  if (!inherits(object, "PvInd")) stop("object must be of class PvInd")
  detectCriter <- match.arg(detectCriter)
  ## for test
  if (aeLab=="all") y <- object@ae[,1]
  x <- object@drug
  nObs <- length(y)
  print(nObs)
  sizeBoot <- round(nObs*.80)
  if(parallel && is.null(nCore)){
    nCore <- parallel:::detectCores()
  }
  print(nCore)
  resBeta <- NULL
  dfmax <- 50
  resGlmnet <- glmnet(x, y, family="gaussian", standardize=F, dfmax=dfmax, lower.limits=0, nlambda=nlambda)
  resGlmnet
  
}

.paraStabSel <- function(idSel, x, y, alpha, family, lambda) {
  resGlmnet <- glmnet(x[idSel,], y[idSel], alpha = alpha, family = family, lambda = lambda, lower.limits=0)
  resGlmnet$beta>0
}

.paraStabSel2 <- function(idSel, x, y, alpha, family, lambda) {
  resGlmnet <- glmnet(x[idSel,], y[idSel], alpha = alpha, family = family, lambda = lambda, lower.limits=0)
  resGlmnet$beta>0
}

# if (detectCriter=="stabSel"){
#   idSel <- as.data.frame(matrix(sample(1:nObs, nBoot*sizeBoot, replace=T), ncol=nBoot, nrow=sizeBoot))
#   print(head(idSel[,1:10]))
#   if (parallel){
#     resBeta <- mclapply(idSel, .paraStabSel2, x, y, 1, family ="gaussian")
#   }else{
#     resBeta <- lapply(idSel, .paraStabSel2, x, y, 1, family ="gaussian")
#   }
#   minCol <- min(unlist(lapply(resBeta, ncol)))
#   print(maxCol) 
#   betaSel <- Reduce('+', resBeta)
# }
